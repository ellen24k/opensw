<!--
## 3계층 저장 구조(MySQL, Redis, 내부 메모리 캐시)로 구성.

### 1. 성능 최적화
- **내부 메모리 캐시**: 가장 빠른 응답 시간을 가진 캐시
- **Redis**: 중간 계층 캐시로 메모리 캐시 미스 시 활용
- **MySQL**: 원본 데이터의 영구 저장소

### 2. 부하 분산
- 대부분의 요청이 메모리 캐시에서 처리되어 Redis와 MySQL의 부하 감소
- 트래픽 급증 시에도 DB 과부하를 방지

### 3. 확장성
- k3s의 HPA를 통해 부하에 따라 Pod 수를 자동으로 조절
- 캐시가 있어 서비스 확장 시에도 DB 병목 현상 방지

## 캐시 TTL 조절에 따른 영향

### 짧은 TTL (낮은 값)
- 데이터 최신성 향상
- 캐시 미스 증가로 Redis 조회 빈도 증가
- 시스템 부하 증가 가능성

### 긴 TTL (높은 값)
- 시스템 부하 감소, 더 나은 응답 시간
- 데이터 일관성 저하 가능성
- 평균 메모리 사용량 증가

## 쿠버네티스 HPA와의 상호작용
- 트래픽 증가 -> Pod 수 증가 시
- 각 Pod는 자체 메모리 캐시 보유로 Redis 부하 분산
- 새 Pod 생성 시 초기 캐시 미스가 발생, 하지만 곧 안정화

-->


## 성능 및 부하 테스트

### 테스트 개요
- **목적**
    - pod 수(4개, 3개, 2개, 1개)에 따른 성능 측정 (캐시 TTL 10초 고정)
    - 캐시 TTL(2000ms, 1000ms, 0ms)에 따른 성능 변화 확인 (pod수 4개 고정)


- **테스트 도구**
    - K6: 성능 및 부하 테스트 도구로, JavaScript로 작성된 스크립트를 사용하여 API를 호출하고 성능 데이터를 수집합니다.
    - InfluxDB: K6에서 수집한 성능 데이터를 저장하는 시계열 데이터베이스입니다.
    - Grafana: InfluxDB와 연동하여 실시간 모니터링 대시보드를 구성합니다.

### 테스트 내용

- **테스트 환경**
    - k3s version v1.31.5+k3s1
    - influxdb version 2.7.11
    - grafana version 11.4.0
    - redis 7.4.2
    - ubuntu 24.04.2 LTS
    - 4 vCPU, 24GB RAM, aarch64 KVM.


- **테스트 조건**
    - 최대 500 VU가 1초마다 2개의 API(Light API + Heavy API)를 30초동안 호출.

| **테스트 시간 (초)** | **VU (Virtual Users)** | **누적 시간 (초)** |
|----------------|------------------------|---------------|
| 10             | 1~500                  | 10            |
| 30             | 500                    | 40            |
| 10             | 500~0                  | 50            |


- **테스트 유형별 데이터 크기**

| **테스트 유형**                                    | **데이터 크기**   |
|-----------------------------------------------|--------------|
| 원본 JSON 데이터                                   | 470 Kbytes   |
| Light API : `/query-classroom-table/1공/401-1` | 460 bytes    |
| Heavy API : `/query-building-table/소프트`       | 35,861 bytes |


### 테스트 결과

#### **Replica 수(4개, 3개, 2개, 1개)에 따른 성능 측정 테스트 결과 (캐시 TTL 10초 고정)**

- **4 Replica**

![측정결과4](https://github.com/ellen24k/opensw/raw/backend-develop-feature/readme/resources/측정결과4.png)

- **3 Replica**

![측정결과3](https://github.com/ellen24k/opensw/raw/backend-develop-feature/readme/resources/측정결과3.png)

- **2 Replica**

![측정결과2](https://github.com/ellen24k/opensw/raw/backend-develop-feature/readme/resources/측정결과2.png)

- **1 Replica**

![측정결과1](https://github.com/ellen24k/opensw/raw/backend-develop-feature/readme/resources//측정결과1.png)

#### **캐시 TTL(2000ms,1000ms,0ms)에 따른 성능 변화 확인 테스트 결과 (Replica 4개 고정)**

- **캐시 TTL 2000ms**

![측정결과2000](https://github.com/ellen24k/opensw/raw/backend-develop-feature/readme/resources/측정결과2000.png)

- **캐시 TTL 1000ms**

![측정결과1000](https://github.com/ellen24k/opensw/raw/backend-develop-feature/readme/resources/측정결과1000.png)

- **캐시 TTL 0ms**

![측정결과0](https://github.com/ellen24k/opensw/raw/backend-develop-feature/readme/resources/측정결과0.png)



### 성능 테스트 결과 요약
- **4 Replica, 2 Replica, 1 Replica** 에 따른 성능 비교표

  | **Replica 수** | **응답 시간 (P90)** | **응답 시간 (P95)** | **처리율**       | **에러율**       |
    |---------------|---------------------|---------------------|------------------|------------------|
  | 1 Replica     | 120ms              | 150ms              | 500 req/sec      | 0.5%            |
  | 2 Replica     | 80ms               | 100ms              | 1000 req/sec     | 0.2%            |
  | 4 Replica     | 60ms               | 80ms               | 2000 req/sec     | 0.1%            |


- 캐시 TTL **0초, 1초, 5초, 10초, 30초**에 따른 성능 비교표

  | **캐시 TTL (초)** | **응답 시간 (P90)** | **응답 시간 (P95)** | **처리율**       | **에러율**       |
    |-------------------|---------------------|---------------------|------------------|------------------|
  | 0                 | 150ms              | 180ms              | 400 req/sec      | 0.8%            |
  | 5                 | 100ms              | 120ms              | 800 req/sec      | 0.4%            |
  | 10                | 80ms               | 100ms              | 1200 req/sec     | 0.2%            |
  | 30                | 60ms               | 80ms               | 2000 req/sec     | 0.1%            |


### 한계점
- InfluxDB와 Grafana가 API와 동일한 서버에서 작동하여, 서버 자원 소모가 많아 API 서버가 자원을 온전히 활용하지 못함.
